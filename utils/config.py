import os
import logging


def update_env_file(var_name: str, var_value: str, logger: logging.Logger):
    """
    Update the .env file with a new environment variable.

    If the .env file already contains the specified variable, it will be updated.
    The new value will be appended to the .env file if it doesn't exist.
    If the .env file does not exist, it will be created.

    Args:
        var_name: The name of the environment variable to update
        var_value: The value to set for the environment variable
        logger: Logger instance for output
    """
    lines = []
    # Read existing contents if file exists
    if os.path.exists('.env'):
        with open('.env', 'r') as env_file:
            lines = env_file.readlines()

        # Remove any existing line with this variable
        lines = [line for line in lines if not line.startswith(f"{var_name}=")]
    else:
        # Log when we're creating a new .env file
        logger.info("Creating new .env file")

    # Sanitize value to avoid breaking lines
    sanitized_value = str(var_value).replace("\r", "").replace("\n", "")
    # Normalize existing lines to always end with a newline
    normalized_lines = [ln if ln.endswith("\n") else ln + "\n" for ln in lines]
    content = "".join(normalized_lines)
    if content and not content.endswith("\n"):
        content += "\n"
    # Write back all lines including the new variable
    with open('.env', 'w') as env_file:
        env_file.write(content)
        env_file.write(f"{var_name}={sanitized_value}\n")
    
    logger.debug(f"Environment variable {var_name} written to .env: {var_value}")


def generate_registry_file(
    entries: list[tuple[str, str, str]],
    logger: logging.Logger,
    registry_path: str = os.path.join("utils", "registry.py"),
) -> None:
    """
    Generate the utils/registry.py file from a list of entries.

    Each entry is a tuple of (function_name, import_path, template_path).
    - import_path: module path like 'utils.custom_functions'
    - template_path: path relative to templates dir (e.g., 'components/widget.html'). Optional.

    The generated file will import functions, add them to TOOL_REGISTRY,
    and update TEMPLATE_REGISTRY with template paths (when provided).
    """
    # Normalize and validate
    normalized: list[tuple[str, str, str]] = []
    for fn_name, imp_path, tpl_path in entries:
        fn = (fn_name or "").strip()
        mod = (imp_path or "").strip()
        tpl = (tpl_path or "").strip()
        if not fn or not mod:
            continue
        if not fn.isidentifier():
            raise ValueError(f"Invalid function name: {fn}")
        # Normalize template path if provided: strip leading './', '/', and optional 'templates/' prefix
        if tpl:
            if tpl.startswith("./"):
                tpl = tpl[2:]
            if tpl.startswith("/"):
                tpl = tpl[1:]
            if tpl.startswith("templates/"):
                tpl = tpl[len("templates/"):]
        normalized.append((fn, mod, tpl))

    if not normalized:
        raise ValueError("No valid registry entries provided")

    # Group functions by module for combined import lines
    from collections import defaultdict
    module_to_functions: dict[str, list[str]] = defaultdict(list)
    for fn, mod, _ in normalized:
        if fn not in module_to_functions[mod]:
            module_to_functions[mod].append(fn)

    # Build code sections
    header_lines: list[str] = [
        "from utils.function_calling import ToolRegistry",
        "",
        "# Auto-generated by Setup UI. Changes may be overwritten.",
    ]

    import_lines: list[str] = []
    for mod in sorted(module_to_functions.keys()):
        fns = ", ".join(sorted(module_to_functions[mod]))
        import_lines.append(f"from {mod} import {fns}")

    body_lines: list[str] = [
        "",
        "TEMPLATE_REGISTRY: dict[str, str | tuple[str, callable]] = {}",
        "TOOL_REGISTRY = ToolRegistry()",
        "",
    ]

    # Add registrations
    for fn, _, _ in normalized:
        body_lines.append(f"TOOL_REGISTRY.add_function({fn})")

    # Add template mappings (only for those with a template path)
    body_lines.append("TEMPLATE_REGISTRY.update({")
    for fn, _, tpl in normalized:
        if tpl:
            body_lines.append(f"    \"{fn}\": \"{tpl}\",")
    body_lines.append("})")

    content = "\n".join(header_lines + import_lines + body_lines) + "\n"

    # Ensure directory exists
    os.makedirs(os.path.dirname(registry_path), exist_ok=True)
    with open(registry_path, "w", encoding="utf-8") as f:
        f.write(content)
    logger.info(f"Wrote registry file to {registry_path}")


def read_registry_entries(
    registry_path: str = os.path.join("utils", "registry.py"),
) -> list[dict[str, str]]:
    """
    Read the current utils/registry.py and extract registered functions for the UI.

    Returns a list of dicts with keys: function_name, import_path, template_path.
    Only functions explicitly registered via TOOL_REGISTRY.add_function(...) are included.
    """
    if not os.path.exists(registry_path):
        return []

    import re
    with open(registry_path, "r", encoding="utf-8") as f:
        content = f.read()

    # Find registered function names
    registered_functions = set(
        re.findall(r"TOOL_REGISTRY\.add_function\(\s*([A-Za-z_][A-Za-z0-9_]*)\s*\)", content)
    )

    if not registered_functions:
        return []

    # Map functions to modules from import lines: from module import fn1, fn2
    fn_to_module: dict[str, str] = {}
    for mod, names in re.findall(r"^from\s+([A-Za-z0-9_\.]+)\s+import\s+([A-Za-z0-9_,\s]+)$", content, flags=re.MULTILINE):
        for name in [n.strip() for n in names.split(",") if n.strip()]:
            if name in registered_functions:
                fn_to_module[name] = mod

    # Map functions to templates inside TEMPLATE_REGISTRY.update({...})
    fn_to_template: dict[str, str] = {}
    for fn, tpl in re.findall(r"[\"']([A-Za-z0-9_]+)[\"']\s*:\s*[\"']([^\"']+)[\"']", content):
        if fn in registered_functions:
            fn_to_template[fn] = tpl

    entries: list[dict[str, str]] = []
    for fn in sorted(registered_functions):
        entries.append({
            "function_name": fn,
            "import_path": fn_to_module.get(fn, ""),
            "template_path": fn_to_template.get(fn, ""),
        })
    return entries